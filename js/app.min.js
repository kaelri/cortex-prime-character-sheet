window.cortexFunctions = {

	arraysMatch: function( a, b ) {
		if ( !Array.isArray(a) || !Array.isArray(b) ) return false;
		if ( a.length !== b.length ) return false;
		for (let i = 0; i < a.length; i++) {
			if ( a[i] !== b[i] ) return false;
		}
		return true;
	},

	getDieDisplayValue: function( dieValue ) {
		switch ( dieValue ) {
			case 4:  return '4';
			case 6:  return '6';
			case 8:  return '8';
			case 10: return '0';
			case 12: return '2';
			default: return '';
		}
	},

	renderDate( timestamp ) {
		let date = new Date( timestamp );
		return date.toLocaleString();
	},

	defaultCharacter: {
		'$schema': 'https://cortex.engard.me/schema/0.1/character.schema.json',
		'version': '0.1',
		'id': '',
		'dateCreated': '',
		'dateModified': '',
		'dateTouched': '',
		'name': 'Name',
		'game': '',
		'description': 'Description',
		'pronouns': '',
		'traitSets': [
			{
				'name': 'Distinctions',
				'description': 'Trait set description',
				'nounSingular': 'Distinction',
				'nounPlural': 'Distinctions',
				'traits': [
					{
						'name': 'Distinction 1',
						'value': 8,
						'description': 'Trait description',
						'traits': [],
						'sfx': [ 'hinder' ],
						'tags': [],
						'custom': {},
					},
					{
						'name': 'Distinction 2',
						'value': 8,
						'description': 'Trait description',
						'traits': [],
						'sfx': [ 'hinder' ],
						'tags': [],
						'custom': {},
					},
					{
						'name': 'Distinction 3',
						'value': 8,
						'description': 'Trait description',
						'traits': [],
						'sfx': [ 'hinder' ],
						'tags': [],
						'custom': {},
					}
				],
				'sfx': [],
				'tags': [],
				'custom': {
					'cortexToolkit': {
						'features': {
							'description': true,
							'sfx': true,
							'subtraits': false
						},
						'location': 'left',
						'style': {
							'header': 'distinctions',
							'body': 'distinctions',
						}
					}
				},
			},
			{
				'name': 'Attributes',
				'description': '',
				'nounSingular': 'Attribute',
				'nounPlural': 'Attributes',
				'traits': [
					{
						'name': 'Attribute 1',
						'value': 8,
						'description': 'Trait description',
						'traits': [],
						'sfx': [],
						'tags': [],
						'custom': {},
					}
				],
				'sfx': [],
				'tags': [],
				'custom': {
					'cortexToolkit': {
						'features': {
							'description': false,
							'sfx': false,
							'subtraits': false
						},
						'location': 'attributes',
						'style': {
							'header': 'attributes',
							'body': 'attributes',
						}
					}
				},
			},
			{
				'name': 'New trait set',
				'description': 'Trait set description',
				'nounSingular': '',
				'nounPlural': '',
				'traits': [
					{
						'name': 'New trait',
						'value': 6,
						'description': 'Trait description',
						'traits': [],
						'sfx': [],
						'tags': [],
						'custom': {},
					}
				],
				'sfx': [],
				'tags': [],
				'custom': {
					'cortexToolkit': {
						'features': {
							'description': false,
							'sfx': false,
							'subtraits': false
						},
						'location': 'left',
						'style': {
							'header': 'default',
							'body': 'default',
						}
					}
				},
			}
		],
		'portrait': {
			'url': '',
			'alt': '',
			'tags': [],
			'custom': {
				'cortexToolkit': {
					'alignment': 'top-center'
				}
			}
		},
		'plotPoints': 0,
		'notes': '',
		'tags': [],
		'custom': {
			'cortexToolkit': {
				'style': {
					'hasAttributes': true,
				}
			}
		}
	},
	
	defaultTraitSet: {
		name: 'New trait set',
		description: 'Trait set description',
		nounSingular: '',
		nounPlural: '',
		traits: [],
		sfx: [],
		tags: [],
		custom: {
			'cortexToolkit': {
				features: {
					description: false,
					sfx: false,
					subtraits: false
				},
				location: 'left',
				style: {
					header: 'default',
					body: 'default',
				}
			}
		}
	},
	
	defaultTrait: {
		name: 'New trait',
		value: 6,
		description: 'Trait description',
		traits: [],
		sfx: [],
		tags: [],
		custom: {}
	},
	
	defaultSFX: {
		name: 'New SFX',
		description: 'SFX description',
		tags: [],
		custom: {}
	},
	
}

const Roster = {

	props: {
		characters: Array,
	},

	computed: {

		charactersSorted() {
			return this.characters.sort((a, b) => {

				let aDate = Math.max( ( new Date(a.dateCreated)).toISOString(), ( new Date(a.dateModified)).toISOString(), ( new Date(a.dateTouched) ).toISOString() );
				let bDate = Math.max( ( new Date(b.dateCreated)).toISOString(), ( new Date(b.dateModified)).toISOString(), ( new Date(b.dateTouched) ).toISOString() );

				return aDate - bDate;

			});
		}

	},

	/*html*/
	template: `<section class="roster">
		<div class="roster-inner">
	
			<!-- BUTTON: ADD/IMPORT CHARACTER -->
			<div class="roster-button-container">
				<div class="roster-button-container-inner">

					<div class="roster-button"
						@click.stop="createCharacter"
					>
						<span><i class="fas fa-plus"></i> New Character</span>
					</div>

					<div class="roster-button roster-button-import"
						@click.stop="importCharacterStart"
					>
						<span><i class="fas fa-upload"></i> Import Character</span>
					</div>

				</div>
			</div>

			<!-- CHARACTER LIST -->
			<ul class="roster-list">

				<transition-group appear>
				<li class="roster-item"
					v-for="character in charactersSorted" :key="character.id"
				>

					<div>

						<div :class="'roster-item-portrait alignment-' + character.portrait.custom.cortexToolkit.alignment"
							:style="'background-image: url(' + character.portrait.url + ');'"
							@click.stop="loadCharacter( character.id )"
						>
							<div class="roster-item-portrait-placeholder" v-if="!character.portrait.url.length"><i class="fas fa-user"></i></div>
						</div>

					</div>

					<div>

						<h3 class="roster-item-name" v-text="character.name"
							@click.stop="loadCharacter( character.id )"
						></h3>
						
						<div class="roster-description" v-text="character.description"></div>

						<div class="roster-date">
							<span class="roster-date-label">Last modified: </span>
							<span v-html="renderDate(character.dateModified)"></span>
						</div>

						<div class="roster-item-button-container">
							<div class="roster-item-button-container-inner">

								<!-- LOAD -->
								<div class="roster-item-button"
									@click.stop="loadCharacter( character.id )"
								>
									<span><i class="fas fa-eye"></i> Open</span>
								</div>

								<!-- EXPORT -->
								<div class="roster-item-button roster-button-export"
									@click.stop="exportCharacter( character.id )"
								>
									<span><i class="fas fa-download"></i> Export</span>
								</div>

								<!-- DELETE -->
								<div class="roster-item-button roster-button-delete"
									@click.stop="deleteCharacter( character.id )"
								>
									<span><i class="fas fa-trash"></i> Delete</span>
								</div>

							</div>
						</div>

					</div>

				</li>
				</transition-group>

			</ul>

			<!-- BUTTON: ADD/IMPORT CHARACTER -->
			<!-- <div class="roster-button-container">
				<div class="roster-button-container-inner">

					<div class="roster-button"
						@click.stop="createCharacter"
					>
						<span><i class="fas fa-plus"></i> New Character</span>
					</div>

					<div class="roster-button roster-button-import"
						@click.stop="importCharacterStart"
					>
						<span><i class="fas fa-upload"></i> Import Character</span>
					</div>

				</div>
			</div> -->

			<!-- FILE INPUT -->
			<input class="roster-input" type="file" ref="inputFile" @change="importCharacter" multiple>

		</div>
	</section>`,

	methods: {

		createCharacter() {
			this.$emit('createCharacter');
		},

		loadCharacter( characterID ) {
			this.$emit('loadCharacter', characterID);
		},

		exportCharacter( characterID ) {
			this.$emit('exportCharacter', characterID);
		},

		deleteCharacter( characterID ) {
			this.$emit('deleteCharacter', characterID);
		},

		importCharacterStart() {
			this.$refs.inputFile.click();
		},

		importCharacter( event ) {

			if ( !event.target.files || !event.target.files.length ) {
				return;
			}

			for (let i = 0; i < event.target.files.length; i++) {
				const file = event.target.files[i];
				
				let reader = new FileReader();
				reader.readAsText(file);
				reader.onload = () => {

					let character = JSON.parse( reader.result );

					this.$emit('importCharacter', character);

				};
				reader.onerror = (error) => {
					console.error('Import error: ', error);
				};

			}

		},

		renderDate( timestamp ) {
			return window.cortexFunctions.renderDate(timestamp);
		},

	}

}

const Character = {

	props: {
		submode:   String,
		character: Object,
		editing:   Array,
		viewY:     Number,
	},

	computed: {

		name() {
			return this.character?.name ?? '';
		},

		description() {
			return this.character?.description ?? '';
		},

		pronouns() {
			return this.character?.pronouns ?? '';
		},

		portrait() {
			return this.character?.portrait ?? null;
		},

		traitSets() {
			return this.character?.traitSets ?? [];
		},

		attributes() {
			return this.traitSets.find( traitSet => traitSet.custom.cortexToolkit.location === 'attributes' )?.traits || [];
		},

		attributesID() {
			return this.traitSets.findIndex( traitSet => traitSet.custom.cortexToolkit.location === 'attributes' );
		}

	},

	/*html*/
	template: `<section :class="'character-sheet submode-' + submode">
	
		<!-- BUTTON: ADD ATTRIBUTE -->
		<transition appear>
		<div class="preview-button-container"
			v-show="submode === 'print'"
		>
			<div class="preview-button-container-inner">
				<div class="preview-button"
					@click.stop="print"
				>
					<span><i class="fas fa-print"></i> Print</span>
				</div>
				<div class="preview-button preview-button-export"
					@click.stop="exportCharacter"
				>
					<span><i class="fas fa-download"></i> Export</span>
				</div>
			</div>
		</div>
		</transition>

		<div class="pages">

			<!-- PAGE -->
			<div class="page">
				<div class="page-inner">

					<header class="page-header">

						<div :class="{'page-header-inner': true, 'selected': isSelected(['name'])}"
							@click.stop="selectElement([ 'name' ])"
						>
							<div>

								<!-- CHARACTER NAME -->
								<div class="title-container">

									<div class="title"
										v-html="name"
									></div>

									<div class="title-decoration">
										<svg height="4" width="100%"><line x1="0" y1="0" x2="10000" y2="0" style="stroke:#C50852;stroke-width:4pt"/></svg>
									</div>

								</div>

								<!-- CHARACTER DESCRIPTION -->
								<div class="character-meta">
						
									<div class="character-pronouns" v-if="pronouns.length">
										<span v-html="renderText(pronouns)"></span>
									</div>

									<div class="character-description" v-if="description.length">
										<span v-html="renderText(description)"></span>
									</div>
			
								</div>

							</div>
						</div>

						<transition name="editor" appear>
							<name-editor
								:character="character"
								:open="isSelected(['name'])"
								v-show="submode === 'edit' && isSelected(['name'])"
								@selectElement="selectElement"
								@updateCharacter="updateCharacter"
							></name-editor>
						</transition>

					</header>

					<!-- COLUMNS -->
					<div class="columns">

						<div v-for="pageLocation in ['left', 'right']" :class="'column-' + pageLocation">

							<!-- PORTRAIT -->
							<div class="portrait" v-if="pageLocation === 'right'">

								<div :class="{ 'portrait-inner': true, 'selected': isSelected(['portrait']) }"
									@click.stop="selectElement([ 'portrait' ])"
								>
									<div :class="'portrait-circle portrait-alignment-' + portrait.custom.cortexToolkit.alignment" width="100%" height="100%" :style="'background-image: url(' + portrait.url + ');'">
										<div class="portrait-placeholder" v-if="!portrait.url.length"><i class="fas fa-user"></i></div>
									</div>
								</div>

								<transition name="editor" appear>
									<portrait-editor
										:character="character"
										:open="isSelected(['portrait'])"
										v-show="submode === 'edit' && isSelected(['portrait'])"
										@selectElement="selectElement"
										@updateCharacter="updateCharacter"
									></portrait-editor>
								</transition>
	
							</div>

							<!-- ATTRIBUTES -->
							<div :class="{ 'attributes': true, 'vertical': attributes.length > 5 }" v-if="pageLocation === 'right' && attributesID > -1">

								<div class="attributes-grid">

									<div class="attribute-curve" xmlns="http://www.w3.org/2000/svg"
										:style="'display: ' + ( attributes.length >= 2 ? 'block' : 'none' ) + ';'"
										v-if="pageLocation === 'right'"
									>
										<svg viewBox="0 0 62 62" width="62mm" height="30mm" preserveAspectRatio="xMidYMid slice">
											<path d="M -17 -25 A 32 32 0 0 0 79 0" stroke="#C50852" stroke-width="0.5mm" fill="transparent" vector-effect="non-scaling-stroke"/>
										</svg>

									</div>

									<div class="attributes-items"
										v-if="pageLocation === 'right'"
									>
										<div v-for="( attribute, a ) in attributes"
											class="attribute"
											:style="getAttributeStyle( a )"
										>

											<div class="attribute-inner"
												:class="{ 'attribute-inner': true, 'selected': isSelected(['trait', attributesID, a]) }"
												@click.stop="selectElement([ 'trait', attributesID, a ])"
											>

												<span class="c"
													v-html="renderDieValue(attribute.value)"
												></span>

												<div class="attribute-name"
													v-html="attribute.name"
												></div>

											</div>

											<transition name="editor" appear>
												<trait-editor
													:character="character"
													:open="isSelected(['trait', attributesID, a])"
													v-show="submode === 'edit' && isSelected(['trait', attributesID, a])"
													:traitSetID="attributesID"
													:traitID="a"
													:viewY="viewY"
													@selectElement="selectElement"
													@updateCharacter="updateCharacter"
													@removeTrait="removeTrait"
												></trait-editor>
											</transition>

										</div>

									</div>

								</div>

								<!-- BUTTON: ADD ATTRIBUTE -->
								<transition appear>
								<div class="preview-button-container"
									v-show="submode === 'edit'"
									v-if="pageLocation === 'right'"
								>
									<div class="preview-button-container-inner">
										<div class="preview-button"
											@click.stop="addTrait( attributesID )"
										>
											<span><i class="fas fa-plus"></i> Attribute</span>
										</div>
									</div>
								</div>
								</transition>

							</div>
								
							<!-- TRAIT SETS -->
							<template v-for="(traitSet, s) in traitSets" :key="s">
							
							<div :class="getTraitSetClasses(traitSet)"
								v-if="traitSet.custom.cortexToolkit.location === pageLocation"
							>

								<div class="trait-set-header">

									<transition appear>
										<div :class="{'trait-set-header-inner': true, 'selected': isSelected(['traitSet', s])}"
											@click.stop="selectElement([ 'traitSet', s ])"
										>
											<div v-html="traitSet.name"></div>
										</div>
									</transition>

									<transition name="editor" appear>
										<trait-set-editor
											:character="character"
											:open="isSelected(['traitSet', s])"
											v-show="submode === 'edit' && isSelected(['traitSet', s])"
											:traitSetID="s"
											:viewY="viewY"
											@selectElement="selectElement"
											@updateCharacter="updateCharacter"
											@removeTraitSet="removeTraitSet"
										></trait-set-editor>
									</transition>

								</div>

								<div class="trait-set-body">

									<div class="trait-list">

										<template v-for="(trait, t) in traitSet.traits" :key="t">
											<div :class="getTraitClasses(trait)">

												<transition name="trait" appear>
													<div :class="{ 'trait-inner': true, 'selected': isSelected(['trait', s, t]) }"
														@click.stop="selectElement([ 'trait', s, t ])"
													>

														<h2 class="trait-title">

															<span class="trait-name"
																v-html="trait.name"
															></span>
														
															<div class="trait-value">
																<span :class="{ 'c': true, 'active': trait.value === 4 }" >4</span>
																<span :class="{ 'c': true, 'active': trait.value === 6 }" >6</span>
																<span :class="{ 'c': true, 'active': trait.value === 8 }" >8</span>
																<span :class="{ 'c': true, 'active': trait.value === 10 }">0</span>
																<span :class="{ 'c': true, 'active': trait.value === 12 }">2</span>
															</div>

														</h2>

														<div
															class="trait-description"
															v-if="traitSet.custom.cortexToolkit.features.description"
															v-html="renderText(trait.description)"
														></div>

														<ul class="subtraits" v-if="traitSet.custom.cortexToolkit.features.subtraits && trait.traits.length">
															<li class="subtrait" v-for="(subtrait, u) in trait.traits">

																<span class="subtrait-name"
																	v-html="subtrait.name"
																></span>
															
																<div class="subtrait-value">
																	<span :class="{ 'c': true, 'active': subtrait.value === 4 }" >4</span>
																	<span :class="{ 'c': true, 'active': subtrait.value === 6 }" >6</span>
																	<span :class="{ 'c': true, 'active': subtrait.value === 8 }" >8</span>
																	<span :class="{ 'c': true, 'active': subtrait.value === 10 }">0</span>
																	<span :class="{ 'c': true, 'active': subtrait.value === 12 }">2</span>
																</div>

															</li>
														</ul>

														<ul class="trait-sfx" v-if="traitSet.custom.cortexToolkit.features.sfx && ( trait.sfx.length )">
															<li v-if="trait.hinder">

															</li>
															<li v-for="(sfx, s) in trait.sfx">

																<template v-if="sfx === 'hinder'">

																	<span class="trait-sfx-name">Hinder</span>:

																	<span class="trait-sfx-description"
																		v-html="renderText('Gain a PP when you switch out this ' + ( traitSet.nounSingular && traitSet.nounSingular.length ? traitSet.nounSingular : 'trait' ) + '’s d' + trait.value + ' for a d4.')"
																	></span>

																</template>

																<template v-else>

																	<span class="trait-sfx-name"
																		v-html="sfx.name"
																	></span>:

																	<span class="trait-sfx-description"
																		v-html="renderText(sfx.description)"
																	></span>

																</template>

															</li>
														</ul>

													</div>
												</transition>

												<transition name="editor" appear>
													<trait-editor
														:character="character"
														:open="isSelected(['trait', s, t])"
														v-show="submode === 'edit' && isSelected(['trait', s, t])"
														:traitSetID="s"
														:traitID="t"
														:viewY="viewY"
														@selectElement="selectElement"
														@updateCharacter="updateCharacter"
														@removeTrait="removeTrait"
													></trait-editor>
												</transition>

											</div>
										</template>

									</div> <!-- .trait-list -->

									<!-- BUTTON: ADD TRAIT -->
									<transition appear>
									<div class="preview-button-container"
										v-show="submode === 'edit'"
									>
										<div class="preview-button-container-inner">
											<div class="preview-button"
												@click.stop="addTrait( s, traitSetLocation )"
											>
												<span><i class="fas fa-plus"></i> {{ traitSet.nounSingular && traitSet.nounSingular.length ? traitSet.nounSingular : 'Trait' }}</span>
											</div>
										</div>
									</div>
									</transition>

									<ul class="sfx" v-if="traitSet.custom.cortexToolkit.features.sfx && traitSet.sfx.length">
										<li v-for="(sfx, s) in traitSet.sfx">

											<span class="sfx-name"
												v-html="sfx.name"
											></span>:

											<span class="sfx-description"
												v-html="renderText(sfx.description)"
											></span>

										</li>
									</ul>

								</div> <!-- .traits -->

							</div>
							</template>

							<!-- BUTTON: ADD TRAIT SET -->
							<transition appear>
							<div class="preview-button-container"
								v-show="submode === 'edit'"
							>
								<div class="preview-button-container-inner">
									<div class="preview-button"
										@click.stop="addTraitSet( pageLocation )"
									>
										<span><i class="fas fa-plus"></i> Trait Set</span>
									</div>
								</div>
							</div>
							</transition>
							
						</div>

					</div> <!-- .columns -->
				</div> <!-- .page-inner -->
			</div> <!-- .page -->
		</div> <!-- .pages -->
	</section>`,

	methods: {

		// PRESENTATION

		isSelected( selector ) {
			return cortexFunctions.arraysMatch( this.editing, selector );
		},

		renderText( text ) {
			text = text.replace( /d\d*(\d)/g, '<span class="c">$1</span>' );
			// text = text.replace( '<span class="c">1(\d)</span>', '<span class="c">$1</span>' );
			text = text.replace( /([^A-Za-z])PP([^A-Za-z])/gi, '$1<span class="pp">PP</span>$2' );
			text = text.replace( "\n", '<br>' );
			return text;
		},

		renderDieValue( value ) {
			return cortexFunctions.getDieDisplayValue( value );
		},

		getTraitSetClasses( traitSet ) {

			let classes = {
				'trait-set': true
			}

			classes[ 'trait-set-style-' + traitSet.custom.cortexToolkit.style.body ] = true;

			if ( traitSet.custom.cortexToolkit.features.description ) {
				classes[ 'trait-set-has-feature-description' ] = true;
			}

			if ( traitSet.custom.cortexToolkit.features.sfx ) {
				classes[ 'trait-set-has-feature-sfx' ] = true;
			}

			if ( traitSet.custom.cortexToolkit.features.subtraits ) {
				classes[ 'trait-set-has-feature-subtraits' ] = true;
			}

			return classes;

		},

		getTraitClasses( trait ) {

			let classes = {
				'trait': true
			}

			if ( trait.description.length ) {
				classes['trait-has-description'] = true;
			}

			if ( trait.sfx.length ) {
				classes['trait-has-sfx'] = true;
			}

			if ( trait.sfx.length ) {
				classes['trait-has-subtraits'] = true;
			}

			return classes;

		},

		getAttributeStyle( a ) {

			let top    = 7;
			let left   = 8;
			let right  = left + 61;
			let height = 10;

			let alpha;

			if ( this.attributes.length === 1 ) {
				alpha = .5;
			} else {
				alpha = a / ( this.attributes.length - 1 );
			}

			let x = (right - left) * alpha + left + 3.5;
			let y = Math.sin(alpha * Math.PI) * height + top - 3;
			
			return `left: ${x}mm; top: ${y}mm;`;

		},
		
		// SELECTING

		selectElement( selector ) {
			if ( this.submode === 'edit' ) {
				this.$emit( 'selectElement', selector );
			}
		},

		clearSelected() {
			this.$emit('selectElement', []);
		},

		// EDITING

		addTraitSet( location ) {

			let character = this.character;

			let traitSet = structuredClone( cortexFunctions.defaultTraitSet );
			traitSet.custom.cortexToolkit.location = location ?? 'left';
			traitSet.traits.push( structuredClone( cortexFunctions.defaultTrait ) );

			character.traitSets.push( traitSet );

			this.updateCharacter( character );

			let newTraitSetID = character.traitSets.length - 1;
			this.selectElement([ 'traitSet', newTraitSetID ]);

		},

		removeTraitSet( traitSetID ) {

			// if ( this.isSelected(['traitSet', traitSetID]) ) {
				this.clearSelected();
			// }

			let character = this.character;

			character.traitSets.splice(traitSetID, 1);

			this.updateCharacter( character );

		},
		
		addTrait( traitSetID ) {

			let character = this.character;
			let traitSet = character.traitSets[traitSetID];
			let noun = ( traitSet.nounSingular && traitSet.nounSingular.length ) ? traitSet.nounSingular : 'Trait';

			let trait = structuredClone( cortexFunctions.defaultTrait );
			trait.name = 'New ' + noun;

			character.traitSets[traitSetID].traits.push(trait);

			this.updateCharacter( character );
			
			let newTraitID = character.traitSets[traitSetID].traits.length - 1;
			this.selectElement([ 'trait', traitSetID, newTraitID ]);

		},

		removeTrait( traitSetID, traitID ) {

			/*// If we’re removing the trait that is currently selected, switch to the previous trait, or the parent trait set if no other traits remain.
			if ( this.isSelected(['trait', traitSetID, traitID]) ) {
				if ( this.character.traitSets[traitSetID].traits.length > 1) {
					this.selectElement([ 'trait', traitSetID, traitID - 1 ]);
				} else {
					this.select( 'traitSet', traitSetID );
				}
			} else {*/
				this.clearSelected();
			/*}*/

			setTimeout( () => {
				let character = this.character;
				character.traitSets[traitSetID].traits.splice(traitID, 1);
				this.updateCharacter( character );
			}, 200 );

		},

		updateCharacter( character ) {
			this.$emit( 'updateCharacter', character );
		},

		exportCharacter() {
			this.$emit('exportCharacter', this.character.id);
		},

		print() {
			window.print();
		}

	}

}

const NameEditor = {

	props: {
		character: Object,
		open:      Boolean,
	},

	data() {
		return {}
	},

	computed: {

		name: {
			get() {
				return this.character.name;
			},
			set( name ) {
				this.setCharacterProperty( 'name', name );
			}
		},
		
		description: {
			get() {
				return this.character.description;
			},
			set( description ) {
				this.setCharacterProperty( 'description', description );
			}
		},

		pronouns: {
			get() {
				return this.character.pronouns ?? '';
			},
			set( pronouns ) {
				this.setCharacterProperty( 'pronouns', pronouns );
			}
		},
		
	},

	/*html*/
	template: `<aside :class="{ 'editor': true, 'editor-character': true, 'open': open, 'scrollable': false }" @click.stop="">

		<div class="editor-arrow"></div>

		<div class="editor-controls">
			<button @click.stop="selectElement([])"><i class="fas fa-times"></i></button>
		</div>

		<div class="editor-inner">
			<div>

				<div class="editor-fields">

					<div class="editor-field">
						<label>Character Name</label>
						<input type="text" v-model="name" ref="inputName">
					</div>

					<div class="editor-field">
						<label>Pronouns</label>
						<input type="text" v-model="pronouns">
					</div>

					<div class="editor-field">
						<label>Description</label>
						<textarea v-model="description"></textarea>
					</div>

				</div>

			</div>
		</div>
		
	</aside>`,

	watch: {
		open( isOpen, wasOpen ) {
			if ( isOpen && !wasOpen ) {
				this.focusFirstInput();
			}
		}
	},

	methods: {

		selectElement( selector ) {
			this.$emit( 'selectElement', selector );
		},

		async focusFirstInput() {
			await Vue.nextTick();
			this.$refs.inputName.focus();
		},
 
		setCharacterProperty( key, value ) {
			let character = this.character;
			character[ key ] = value;
			this.updateCharacter( character );
		},

		updateCharacter( character ) {
			this.$emit( 'updateCharacter', character );
		},

		doNothing() {
			// This is intentional! 
		}

	}

}

const TraitSetEditor = {

	props: {
		character:  Object,
		traitSetID: Number,
		open:       Boolean,
		viewY:      Number,
	},

	data() {
		return {
			scrollPosition: 'none',
			anchorPosition: 'top',
			styleOptions: [
				{ id: 'default',              label: 'Default' },
				{ id: 'two-columns-compact',  label: 'Two Columns (Compact)' },
				{ id: 'two-columns-detailed', label: 'Two Columns (Detailed)' },
				{ id: 'distinctions',         label: 'Distinctions' },
				{ id: 'assets',               label: 'Assets' },
				{ id: 'resources',            label: 'Resources' },
				{ id: 'stress',               label: 'Stress' },
			]
		}
	},

	computed: {

		traitSet() {
			let s = this.traitSetID;
			return this.character.traitSets[s];
		},

		name: {
			get() {
				return this.traitSet.name;
			},
			set( name ) {
				this.setProperty( 'name', name );
			}
		},

		description: {
			get() {
				return this.traitSet.description;
			},
			set( description ) {
				this.setProperty( 'description', description );
			}
		},

		nounSingular: {
			get() {
				return this.traitSet.nounSingular ?? '';
			},
			set( nounSingular ) {
				this.setProperty( 'nounSingular', nounSingular );
			}
		},

		nounPlural: {
			get() {
				return this.traitSet.nounPlural ?? '';
			},
			set( nounPlural ) {
				this.setProperty( 'nounPlural', nounPlural );
			}
		},

		styleHeader: {
			get() {
				return this.traitSet.custom.cortexToolkit.style.header;
			},
			set( value ) {
				this.setStyle( 'header', value );
			}
		},

		styleBody: {
			get() {
				return this.traitSet.custom.cortexToolkit.style.body;
			},
			set( value ) {
				this.setStyle( 'body', value );
			}
		},

		featureDescription: {
			get() {
				return this.traitSet.custom.cortexToolkit.features.description ?? false;
			},
			set( value ) {
				this.setFeature( 'description', value );
			}
		},

		featureSFX: {
			get() {
				return this.traitSet.custom.cortexToolkit.features.sfx ?? false;
			},
			set( value ) {
				this.setFeature( 'sfx', value );
			}
		},

		featureSubtraits: {
			get() {
				return this.traitSet.custom.cortexToolkit.features.subtraits ?? false;
			},
			set( value ) {
				this.setFeature( 'subtraits', value );
			}
		},

		scrollable() {
			return Boolean(
				this.traitSet.custom.cortexToolkit.features.sfx && this.traitSet.sfx.length > 0
			);
		},

		cssClass() {

			let cssClass = {
				'editor':     true,
				'open':       this.open,
				'scrollable': this.scrollable,
			}

			cssClass[ 'anchor-position-' + this.anchorPosition ] = true;

			return cssClass;

		}

	},

	/*html*/
	template: `<aside :class="cssClass" @click.stop="">

		<div class="editor-arrow"></div>

		<div class="editor-controls">
			<button @click.stop="selectElement([])"><i class="fas fa-times"></i></button>
			<button class="editor-delete" @click.stop="removeTraitSet"><i class="fas fa-trash"></i></button>
		</div>

		<div class="editor-inner">
			<div>

				<div class="editor-fields">

					<div class="editor-field">
						<label>Trait Set Name</label>
						<input type="text" v-model="name" ref="inputName">
					</div>

					<div class="editor-field" v-if="traitSet.location !== 'attributes'">
						<label>Style</label>
						<select v-model="styleBody">
							<option v-for="option in styleOptions" :value="option.id" :selected="option.id === styleBody">{{ option.label }}</option>
						</select>
					</div>

					<div class="editor-field">
						<label>Description</label>
						<textarea v-model="description"></textarea>
					</div>

					<div class="editor-field">
						<label>Singular Noun</label>
						<input type="text" v-model="nounSingular" placeholder="Trait">
					</div>

					<div class="editor-field">
						<label>Trait Features</label>
						<div class="editor-toggles">

							<div><input type="checkbox" :id="'trait-set-' + traitSetID + '-feature-description'" :true-value="true" :false-value="false" v-model="featureDescription"></div>
							<div><label :for="'trait-set-' + traitSetID + '-feature-description'">Description</label></div>

							<div><input type="checkbox" :id="'trait-set-' + traitSetID + '-feature-subtraits'" :true-value="true" :false-value="false" v-model="featureSubtraits"></div>
							<div><label :for="'trait-set-' + traitSetID + '-feature-subtraits'">Sub-Traits</label></div>

							<div><input type="checkbox" :id="'trait-set-' + traitSetID + '-feature-sfx'" :true-value="true" :false-value="false" v-model="featureSFX"></div>
							<div><label :for="'trait-set-' + traitSetID + '-feature-sfx'">SFX</label></div>

						</div>
					</div>

					<!-- SFX -->
					<div class="editor-field" v-if="traitSet.custom.cortexToolkit.features.sfx">

						<label>Trait Set SFX</label>

						<div class="editor-subgroups">

							<transition-group appear>
								<sfx-editor
									v-for="(effect, effectID) in traitSet.sfx"
									:key="traitSetID + '-' + effectID"
									:character="character"
									:traitSetID="traitSetID"
									:traitID="null"
									:effectID="effectID"
									@updateCharacter="updateCharacter"
									@removeEffect="removeEffect"
								></sfx-editor>
							</transition-group>

						</div>

						<div class="editor-button-container">
							<div class="editor-button-container-inner">
								<div class="editor-button" @click.stop="addEffect">
									<span><i class="fas fa-plus"></i> New SFX</span>
								</div>
							</div>
						</div>

					</div>

				</div>

			</div>
		</div>

	</aside>`,

	mounted() {
		this.checkAnchorPosition();
	},

	watch: {

		character() {
			this.checkAnchorPosition();
		},

		viewY() {
			this.checkAnchorPosition();
		},
		
		open( isOpen, wasOpen ) {
			if ( isOpen && !wasOpen ) {
				this.focusFirstInput();
			}
		}

	},

	methods: {

		selectElement( selector ) {
			this.$emit( 'selectElement', selector );
		},

		async focusFirstInput() {
			await Vue.nextTick();
			this.$refs.inputName.focus();
		},
 
		setProperty( key, value ) {

			let character = this.character;
			let s = this.traitSetID;

			character.traitSets[s][ key ] = value;

			this.updateCharacter( character );

		},

		removeTraitSet() {
			this.$emit( 'removeTraitSet', this.traitSetID );
		},

		setFeature( featureID, value ) {

			let s = this.traitSetID;
			
			this.character.traitSets[s].custom.cortexToolkit.features[ featureID ] = value;

			this.updateCharacter( this.character );

		},

		setStyle( styleID, value ) {

			let s = this.traitSetID;
			
			this.character.traitSets[s].custom.cortexToolkit.style[ styleID ] = value;

			this.updateCharacter( this.character );

		},

		addEffect() {

			let character = this.character;
			let s = this.traitSetID;

			character.traitSets[s].sfx.push(
				structuredClone( cortexFunctions.defaultSFX )
			);

			this.updateCharacter( character );

		},

		removeEffect( effectID ) {

			let character = this.character;
			let s = this.traitSetID;
			let f = effectID;

			character.traitSets[s].sfx.splice(f, 1);

			this.updateCharacter( character );

		},

		updateCharacter( character ) {
			this.$emit( 'updateCharacter', character );
		},

		checkAnchorPosition() {
			
			let windowHeight = (window.innerHeight || html.clientHeight);
			let traitPosition = this.$el.parentElement.getBoundingClientRect();
			let traitMidpoint = traitPosition.top + (traitPosition.height / 2); 

			if ( traitMidpoint < (windowHeight / 2) ) {
				this.anchorPosition = 'top';
			} else {
				this.anchorPosition = 'bottom';
			}

		},

	}

}

const TraitEditor = {

	props: {
		character:  Object,
		traitSetID: Number,
		traitID:    Number,
		open:       Boolean,
		viewY:      Number,
	},

	data() {
		return {
			scrollPosition: 'none',
			anchorPosition: 'top',
		}
	},

	computed: {

		traitSet() {
			let s = this.traitSetID;
			return this.character.traitSets[s];
		},

		trait() {
			let s = this.traitSetID;
			let t = this.traitID;
			return this.character.traitSets[s].traits[t];
		},

		name: {
			get() {
				return this.trait.name;
			},
			set( name ) {
				this.setProperty( 'name', name );
			}
		},

		value: {
			get() {
				return this.trait.value;
			},
			set( value ) {
				this.setProperty( 'value', value );
			}
		},

		description: {
			get() {
				return this.trait.description;
			},
			set( description ) {
				this.setProperty( 'description', description );
			}
		},

		hinder: {
			get() {
				return this.trait.sfx.includes('hinder');
			},
			set( value ) {
				this.setHinder( value );
			}
		},

		editableSFX() {
			return this.trait.sfx
			.filter( effect => effect !== 'hinder' )
			.map( effect => this.trait.sfx.indexOf(effect) );
		},

		scrollable() {
			return Boolean(
				( this.traitSet.custom.cortexToolkit.features.sfx && this.editableSFX.length > 0 )
				||
				( this.traitSet.custom.cortexToolkit.features.subtraits && this.trait.traits.length > 0 )
			);
		},

		cssClass() {

			let cssClass = {
				'editor': true,
				'open': this.open,
				'scrollable': this.scrollable
			}

			cssClass[ 'anchor-position-' + this.anchorPosition ] = true;

			if ( this.scrollable ) {
				cssClass[ 'scroll-position-' + this.scrollPosition ] = true;
			}

			return cssClass;

		}

	},

	/*html*/
	template: `<aside :class="cssClass" @click.stop="">

		<div class="editor-arrow"></div>

		<div class="editor-controls">
			<button @click.stop="selectElement([])"><i class="fas fa-times"></i></button>
			<button class="editor-delete" @click.stop="removeTrait"><i class="fas fa-trash"></i></button>
		</div>

		<div class="editor-inner">
			<div @scroll="checkScrollPosition">
	
				<div class="editor-fields">

					<div class="editor-field">
						<label>Trait Name</label>
						<input type="text" v-model="name" ref="inputName">
					</div>

					<div class="editor-field">

						<label>Value</label>

						<ul class="editor-values">
							<li
								v-for="value in [4,6,8,10,12]"
								:class="{ 'active': value === trait.value }"
								@click.stop="toggleTraitValue( value )"
							>
								<span class="c" v-html="getDieDisplayValue(value)"></span>
							</li>
						</ul>

					</div>

					<div class="editor-field" v-if="traitSet.custom.cortexToolkit.features.description">
						<label>Description</label>
						<textarea v-model="description"></textarea>
					</div>

					<!-- SUBTRAITS -->
					<div class="editor-field" v-if="traitSet.custom.cortexToolkit.features.subtraits">

						<label>Subtraits</label>

						<div class="editor-subgroups">

							<transition-group appear>
								<subtrait-editor
									v-for="(subtrait, subtraitID) in trait.traits"
									:key="traitSetID + '-' + traitID + '-' + subtraitID"
									:character="character"
									:traitSetID="traitSetID"
									:traitID="traitID"
									:subtraitID="subtraitID"
									@updateCharacter="updateCharacter"
									@removeSubtrait="removeSubtrait"
								></subtrait-editor>
							</transition-group>

						</div>

						<div class="editor-button-container">
							<div class="editor-button-container-inner">
								<div class="editor-button" @click.stop="addSubtrait">
									<span><i class="fas fa-plus"></i> New Subtrait</span>
								</div>
							</div>
						</div>

					</div>

					<!-- SFX -->
					<div class="editor-field" v-if="traitSet.custom.cortexToolkit.features.sfx">

						<label>SFX</label>

						<div class="editor-field">
							<div class="editor-toggles">
								<div><input type="checkbox" :id="'trait-' + traitSetID + '-' + traitID + '-hinder'" :true-value="true" :false-value="false" v-model="hinder"></div>
								<div><label :for="'trait-' + traitSetID + '-' + traitID + '-hinder'">Can Hinder</label></div>
							</div>
						</div>

						<div class="editor-subgroups">

							<transition-group appear>
								<sfx-editor
									v-for="effectID in editableSFX"
									:key="traitSetID + '-' + traitID + '-' + effectID"
									:character="character"
									:traitSetID="traitSetID"
									:traitID="traitID"
									:effectID="effectID"
									@updateCharacter="updateCharacter"
									@removeEffect="removeEffect"
								></sfx-editor>
							</transition-group>

						</div>

						<div class="editor-button-container">
							<div class="editor-button-container-inner">
								<div class="editor-button" @click.stop="addEffect">
									<span><i class="fas fa-plus"></i> New SFX</span>
								</div>
							</div>
						</div>

					</div>

				</div>

			</div>
		</div>

	</aside>`,

	mounted() {

		this.checkAnchorPosition();
		this.checkScrollPosition();

		if ( this.open ) {
			this.focusFirstInput();
		}

	},

	watch: {

		character() {
			this.checkAnchorPosition();
		},

		viewY() {
			this.checkAnchorPosition();
		},
		
		open( isOpen, wasOpen ) {
			if ( isOpen && !wasOpen ) {
				this.focusFirstInput();
			}
		}

	},

	methods: {

		selectElement( selector ) {
			this.$emit( 'selectElement', selector );
		},

		async focusFirstInput() {
			await Vue.nextTick();
			this.$refs.inputName.focus();
		},
 
		setProperty( key, value ) {

			let character = this.character;
			let s = this.traitSetID;
			let t = this.traitID;

			character.traitSets[s].traits[t][ key ] = value;

			this.updateCharacter( character );

		},

		setHinder( value ) {

			let character = this.character;
			let s = this.traitSetID;
			let t = this.traitID;
			let sfx = character.traitSets[s].traits[t].sfx;

			if ( value === false && sfx.includes('hinder') ) {
				sfx.splice( sfx.indexOf('hinder'), 1 );
			} else if ( value === true && !sfx.includes('hinder') ) {
				sfx.unshift( 'hinder' );
			}

			this.updateCharacter( character );

		},

		toggleTraitValue( value ) {

			if ( value === this.trait.value ) {
				value = null;
			}

			this.setProperty( 'value', value );

		},

		removeTrait() {
			this.$emit( 'removeTrait', this.traitSetID, this.traitID );
		},

		addEffect() {

			let character = this.character;
			let s = this.traitSetID;
			let t = this.traitID;

			character.traitSets[s].traits[t].sfx.push(
				structuredClone( cortexFunctions.defaultSFX )
			);

			this.updateCharacter( character );

		},

		removeEffect( effectID ) {

			let character = this.character;
			let s = this.traitSetID;
			let t = this.traitID;
			let f = effectID;

			character.traitSets[s].traits[t].sfx.splice(f, 1);

			this.updateCharacter( character );

		},

		addSubtrait() {

			let subtrait = structuredClone( cortexFunctions.defaultTrait );
			subtrait.name = 'New subtrait';

			let character = this.character;
			let s = this.traitSetID;
			let t = this.traitID;

			character.traitSets[s].traits[t].traits.push(subtrait);

			this.updateCharacter( character );

		},

		removeSubtrait( subtraitID ) {

			let character = this.character;
			let s = this.traitSetID;
			let t = this.traitID;
			let u = subtraitID;

			character.traitSets[s].traits[t].traits.splice(u, 1);

			this.updateCharacter( character );

		},

		updateCharacter( character ) {
			this.$emit( 'updateCharacter', character );
		},

		checkAnchorPosition() {
			
			let windowHeight = (window.innerHeight || html.clientHeight);
			let traitPosition = this.$el.parentElement.getBoundingClientRect();
			let traitMidpoint = traitPosition.top + (traitPosition.height / 2); 

			if ( traitMidpoint < (windowHeight / 2) ) {
				this.anchorPosition = 'top';
			} else {
				this.anchorPosition = 'bottom';
			}

		},

		checkScrollPosition() {

			let element = this.$el.querySelector('.editor-inner > div');

			let distance = element.scrollTop;
			let max      = element.scrollHeight - element.clientHeight;

			if ( max <= 0 ) {
				this.scrollPosition = 'none';
				return;
			}

			if ( distance === 0 ) {
				this.scrollPosition = 'top';
				return;
			}

			if ( distance >= (max - 1) ) { // slight buffer 
				this.scrollPosition = 'bottom';
				return;
			}

			this.scrollPosition = 'middle';
			return;

		},

		getDieDisplayValue( value ) {
			return cortexFunctions.getDieDisplayValue( value );
		},

	}

};

const SubtraitEditor = {

	props: {
		character:  Object,
		selected:   Array,
		traitSetID: Number,
		traitID:    Number,
		subtraitID: Number,
	},

	data() {
		return {}
	},

	computed: {

		subtrait() {
			let s = this.traitSetID;
			let t = this.traitID;
			let u = this.subtraitID;
			return this.character.traitSets[s].traits[t].traits[u];
		},

		selector() {
			return [ 'subtrait', this.traitSetID, this.traitID, this.subtraitID ];
		},

		name: {
			get() {
				return this.subtrait.name;
			},
			set( name ) {
				this.setSubtraitProperty( 'name', name );
			}
		},

		value: {
			get() {
				return this.subtrait.value;
			},
			set( value ) {
				this.setSubtraitProperty( 'value', value );
			}
		},

	},

	/*html*/
	template: `<section class="editor-subgroup">
	
		<div class="editor-fields">

			<div class="editor-field">
				<label>Subtrait Name</label>
				<input type="text" v-model="name">
			</div>

			<ul class="editor-values">
				<li
					v-for="value in [4,6,8,10,12]"
					:class="{ 'active': value === subtrait.value }"
					@click.stop="toggleSubtraitValue( value )"
				>
					<span class="c" v-html="getDieDisplayValue(value)"></span>
				</li>
			</ul>

			<div class="editor-button-container">
				<div class="editor-button-container-inner">
					<div class="editor-button editor-button-remove editor-button-secondary" @click.prevent="removeSubtrait">
						<span><i class="fas fa-trash"></i> Remove Subtrait</span>
					</div>
				</div>
			</div>

		</div>

	</section>`,

	methods: {

		setSubtraitProperty( key, value ) {

			let character = this.character;
			let s = this.traitSetID;
			let t = this.traitID;
			let f = this.subtraitID;

			character.traitSets[s].traits[t].subtraits[f][ key ] = value;

			this.updateCharacter( character );

		},

		toggleSubtraitValue( value ) {

			if ( value === this.subtrait.value ) {
				value = null;
			}

			this.setSubtraitProperty( 'value', value );

		},

		updateCharacter( character ) {
			this.$emit( 'updateCharacter', character );
		},

		removeSubtrait() {
			this.$emit( 'removeSubtrait', this.subtraitID );
		},

		getDieDisplayValue( value ) {
			return cortexFunctions.getDieDisplayValue( value );
		},

	}

}

const SfxEditor = {

	props: {
		character:  Object,
		selected:   Array,
		traitSetID: Number,
		traitID:    Number,
		effectID:   Number,
	},

	data() {
		return {}
	},

	computed: {

		effect() {
			let s = this.traitSetID;
			let t = this.traitID;
			let f = this.effectID;
			if ( t === null ) {
				return this.character.traitSets[s].sfx[f];
			} else {
				return this.character.traitSets[s].traits[t].sfx[f];
			}
		},

		selector() {
			return [ 'sfx', this.traitSetID, this.traitID, this.effectID ];
		},

		name: {
			get() {
				return this.effect.name;
			},
			set( name ) {
				this.setEffectProperty( 'name', name );
			}
		},

		description: {
			get() {
				return this.effect.description;
			},
			set( description ) {
				this.setEffectProperty( 'description', description );
			}
		},

	},

	/*html*/
	template: `<section class="editor-subgroup">
	
		<div class="editor-fields">

			<div class="editor-field">
				<label>SFX Name</label>
				<input type="text" v-model="name">
			</div>

			<div class="editor-field">
				<label>SFX Description</label>
				<textarea v-model="description"></textarea>
			</div>

			<div class="editor-button-container">
				<div class="editor-button-container-inner">
					<div class="editor-button editor-button-remove editor-button-secondary" @click.prevent="removeEffect">
						<span><i class="fas fa-trash"></i> Remove SFX</span>
					</div>
				</div>
			</div>

		</div>

	</section>`,

	methods: {

		setEffectProperty( key, value ) {

			let character = this.character;
			let s = this.traitSetID;
			let t = this.traitID;
			let f = this.effectID;

			if ( t === null ) {
				character.traitSets[s].sfx[f][ key ] = value;
			} else {
				character.traitSets[s].traits[t].sfx[f][ key ] = value;
			}


			this.updateCharacter( character );

		},

		updateCharacter( character ) {
			this.$emit( 'updateCharacter', character );
		},

		removeEffect() {
			this.$emit( 'removeEffect', this.effectID );
		},

	}

}

const PortraitEditor = {

	props: {
		character: Object,
		open:      Boolean,
	},

	data() {
		return {}
	},

	computed: {

		hasImage() {
			return Boolean( this.character.portrait.url.length );
		},

		alignment: {
			get() {
				return this.character.portrait.custom.cortexToolkit.alignment;
			},
			set( value ) {
				this.setAlignment( value );
			}
		},

	},

	/*html*/
	template: `<aside :class="{ 'editor': true, 'editor-portrait': true, 'open': open, 'scrollable': false, 'anchor-position-top': true }" @click.stop="">

		<div class="editor-arrow"></div>

		<div class="editor-controls">
			<button @click.stop="selectElement([])"><i class="fas fa-times"></i></button>
			<button v-if="hasImage" class="editor-delete" @click.stop="setImageURL('')"><i class="fas fa-trash"></i></button>
		</div>

		<div class="editor-inner">
			<div>

				<div class="editor-fields">

					<div class="editor-field">

						<label>Portrait</label>

						<img class="portrait-preview"
							v-if="hasImage"
							:src="character?.portrait?.url"
							@click.prevent="uploadStart"
						>

						<div class="editor-button-container">
							<div class="editor-button-container-inner">
								<div
									class="editor-button"
									@click.prevent="uploadStart"
								>
									<span><i class="fas fa-plus"></i> Upload {{ hasImage ? 'New' : '' }} Image</span>
								</div>
							</div>
						</div>

						<input class="portrait-input" type="file" ref="inputFile" @change="uploadProcess">

					</div>

					<div class="editor-field" v-if="hasImage">

						<label>Alignment</label>

						<div class="editor-portrait-alignment">
							<div @click.stop="setAlignment('top-left')"      :class="{'active': alignment === 'top-left' }"></div>
							<div @click.stop="setAlignment('top-center')"    :class="{'active': alignment === 'top-center' }"></div>
							<div @click.stop="setAlignment('top-right')"     :class="{'active': alignment === 'top-right' }"></div>
							<div @click.stop="setAlignment('center-left')"   :class="{'active': alignment === 'center-left' }"></div>
							<div @click.stop="setAlignment('center')"        :class="{'active': alignment === 'center' }"></div>
							<div @click.stop="setAlignment('center-right')"  :class="{'active': alignment === 'center-right' }"></div>
							<div @click.stop="setAlignment('bottom-left')"   :class="{'active': alignment === 'bottom-left' }"></div>
							<div @click.stop="setAlignment('bottom-center')" :class="{'active': alignment === 'bottom-center' }"></div>
							<div @click.stop="setAlignment('bottom-right')"  :class="{'active': alignment === 'bottom-right' }"></div>
						</div>

					</div>

				</div>
				
			</div>
		</div>

	</aside>`,

	methods: {

		selectElement( selector ) {
			this.$emit( 'selectElement', selector );
		},

		uploadStart() {
			this.$refs.inputFile.click();
		},

		setImageURL( url ) {
			let character = this.character;
			character.portrait.url = url;
			this.updateCharacter( character );
		},

		setAlignment( alignment ) {
			let character = this.character;
			character.portrait.custom.cortexToolkit.alignment = alignment;
			this.updateCharacter( character );
		},

		uploadProcess( event ) {

			if ( !event.target.files || !event.target.files.length ) {
				this.setImageURL( '' );
				this.setAlignment( 'center' );
				return;
			}
			
			let file = event.target.files[0];

			let reader = new FileReader();
			reader.readAsDataURL(file);
			reader.onload = () => {
				this.setImageURL( reader.result );
			};
			reader.onerror = (error) => {
				console.error('Portrait error: ', error);
			};

		},

		updateCharacter( character ) {
			this.$emit( 'updateCharacter', character );
		}

	}

}

document.addEventListener('DOMContentLoaded', () => {

	app = Vue.createApp({

		name: 'cortex-toolkit',

		data() {
			return {
				localData:    {},
				characters:   [],
				characterID:  null,
				mode:         'roster',
				submode:      null,
				editing:      null,
				viewY:        null,
			}
		},

		computed: {

			baseURL() {
				return window.location.href;
			},

			year() {
				return ( new Date() ).getFullYear();
			},

			characterIndex() {
				return this.characters.findIndex( character => character.id === this.characterID );
			},

			character() {
				return this.characters[ this.characterIndex ];
			},

		},

		/*html*/
		template: `<header class="header">
				<div class="header-inner">
					<nav class="nav-mode">
						<ul>
							<li @click.stop="setMode('roster', null)" :class="{ active: mode === 'roster' }"><div><span class="nav-icon"><i class="fas fa-users"></i></span></div></li>
							<li @click.stop="setMode('character', 'edit')" :class="{ active: mode === 'character' && submode === 'edit', 'disabled': !character }"><div><span class="nav-icon"><i class="fas fa-pencil"></i></span> <span class="nav-label">Create</span></div></li>
							<li @click.stop="setMode('character', 'play')" :class="{ active: mode === 'character' && submode === 'play', 'disabled': !character }"><div><span class="nav-icon"><i class="fas fa-dice"></i></span> <span class="nav-label">Play</span></div></li>
							<li @click.stop="setMode('character', 'print')" :class="{ active: mode === 'character' && submode === 'print', 'disabled': !character }"><div><span class="nav-icon"><i class="fas fa-file"></i></span> <span class="nav-label">Share</span></div></li>
						</ul>
					</nav>
				</div>
			</header>

			<aside class="sidebar">
				<div class="sidebar-inner">
				</div>
			</aside>

			<main class="main" ref="main" @scroll="setViewY"
				@click.stop="clearSelected"
			>
			
				<!-- CHARACTER SHEET -->
				<transition mode="out-in">

					<roster
						v-if="mode === 'roster'"
						:characters="characters"
						@createCharacter="createCharacter"
						@loadCharacter="loadCharacter"
						@exportCharacter="exportCharacter"
						@deleteCharacter="deleteCharacter"
						@importCharacter="importCharacter"
					></roster>

					<character
						v-else-if="mode === 'character' && character"
						:submode="submode"
						:character="character"
						:editing="editing"
						:viewY="viewY"
						@selectElement="selectElement"
						@updateCharacter="updateCharacter"
						@exportCharacter="exportCharacter"
					></character>

					<article class="about"
						v-else-if="mode === 'about'"
					>

						<h1>About Cortex Toolkit</h1>
						
						<p>Cortex Prime is the award-winning world-building tabletop RPG system for forging unique, compelling game experiences from a set of modular rules mechanics available at <a href="https://www.cortexrpg.com" target="_blank">CortexRPG.com</a>.</p>

						<p>Cortex is ©️ {{year}} Dire Wolf Digital, LLC. Cortex, Cortex Prime, associated logos and trade dress are the trademarks of Dire Wolf Digital, LLC. Iconography used with permission.</p>

						<p>If you wish to publish or sell what you make using this tool, it is your responsibility to ensure you have the proper license or right for any resources used. No rights are granted through the use of this tool.</p>

					</article>

				</transition>

			</main>

			<footer class="footer">
				<div class="footer-inner">

					<div class="footer-colophon">
						<a href="https://www.cortexrpg.com" target="_blank"><img src="images/cortex_prime_logo_light_background.png"></a>
					</div>

					<nav class="footer-nav">
						<ul>
							<li @click.stop="setMode('about', null)" :class="{ active: mode === 'about' }"><div><span class="nav-icon"><i class="far fa-question-circle"></i></span></div></li>
							<li><a href="https://github.com/kaelri/cortex-toolkit" target="_blank" title="View on GitHub"><div><span class="nav-icon"><i class="fab fa-github"></i></span></div></a></li>
						</ul>
					</nav>

				</div>
			</footer>
			
			<div class="legal">
			</div>`,
		
		mounted() {

			this.setViewY();
			this.loadLocalData();

		},

		watch: {

			mode() {
				this.setPageTitle();
			},

			characterID() {
				this.setPageTitle();
			}

		},

		methods: {

			// VIEW

			setMode( mode, submode ) {
				if ( mode === 'character' && !this.character ) return;
				this.mode    = mode;
				this.submode = submode;
			},

			setViewY() {
				this.viewY = this.$refs.main.scrollTop;
			},

			setPageTitle() {
				pageTitle = 'Cortex Toolkit';
				if ( this.mode === 'character' && this.character && this.character.name.length ) {
					pageTitle = `${this.character.name} - ${pageTitle}`;
				}
				document.title = pageTitle;
			},

			// DATA

			createCharacter() {

				let character = structuredClone( cortexFunctions.defaultCharacter );

				character.id = crypto.randomUUID();

				character.dateCreated  = ( new Date() ).toISOString();
				character.dateModified = ( new Date() ).toISOString();
				character.dateTouched  = ( new Date() ).toISOString();

				this.characters.push( character );
				this.characterID = character.id;
				this.setMode( 'character', this.submode ?? 'edit' );

				this.saveLocalData();

			},

			deleteCharacter( id ) {
				
				let c = this.characters.findIndex( character => character.id === id );
				if ( c === -1 ) return;

				this.setMode( 'roster', null );
				this.characterID = null;
				this.characters.splice( c, 1 );
				this.setPageTitle();

				this.saveLocalData();

			},

			importCharacter( character, confirm ) {

				character.dateTouched = ( new Date() ).toISOString();

				// Populate custom data sets for this app.
				for (let i = 0; i < character.traitSets.length; i++) {
					const traitSet = character.traitSets[i];

					if ( !traitSet.custom.cortexToolkit ) {
						traitSet.custom.cortexToolkit = structuredClone( cortexFunctions.defaultTraitSet.custom.cortexToolkit );
					}
					
				}

				if ( !character.portrait.custom.cortexToolkit ) {
					character.portrait.custom.cortexToolkit = structuredClone( cortexFunctions.defaultCharacter.portrait.custom.cortexToolkit );
				}

				let c = this.characters.findIndex( existingCharacter => existingCharacter.id === character.id );

				if ( c !== -1 ) {
					this.characters[c] = character;
				} else {
					this.characters.push( character );
				}

				this.saveLocalData();

			},

			loadCharacter( id ) {

				this.characterID = id;

				this.setMode( 'character', this.submode ?? 'edit' );

			},

			exportCharacter( id ) {

				let character = this.characters.find( character => character.id === id );

				let uri = encodeURI("data:application/json;charset=utf-8," + JSON.stringify(character, null, 2))
				.replace(/#/g, '%23');

				let name = character.name.length ? character.name : 'Name';
				let timestamp = ( new Date(character.dateModified) ).getTime();
				name = name.replaceAll( /\s+/g, '_' );
				let filename = `${name}_${timestamp}.cortex.json`;

				let link = document.createElement("a");
				document.body.appendChild(link); // Required for Firefox
				link.setAttribute('href', uri);
				link.setAttribute('download', filename);
				link.click();
				link.remove();

			},

			exportAllCharacters() {

				let uri = encodeURI("data:application/json;charset=utf-8," + JSON.stringify(this.characters))
				.replace(/#/g, '%23');

				let timestamp = ( new Date() ).getTime();
				let filename  = `CortexToolkitData_${timestamp}.json`;

				let link = document.createElement("a");
				document.body.appendChild(link); // Required for Firefox
				link.setAttribute('href', uri);
				link.setAttribute('download', filename);
				link.click();
				link.remove();

			},

			updateCharacter( character ) {

				let c = this.characters.findIndex( savedCharacter => savedCharacter.id === character.id );

				if ( c === -1 ) return;

				character.dateModified = ( new Date() ).toISOString();
				character.dateTouched  = ( new Date() ).toISOString();

				this.characters[c] = character;
				this.setPageTitle();

				this.saveLocalData();

			},

			selectElement( selector ) {

				if ( cortexFunctions.arraysMatch( this.editing, selector ) ) {
					this.editing = [];
					return;
				}

				this.editing = selector;

			},

			clearSelected() {
				this.selectElement([]);
			},

			loadLocalData() {

				let localJSON = localStorage.getItem('cortexToolkitData');
				if ( !localJSON || !localJSON.length ) return;

				let localData = JSON.parse(localJSON);
				if ( !localData || !localData['0.1'] ) return;

				this.localData = localData;

				if ( localData['0.1'].characters ) {
					this.characters = structuredClone( localData['0.1'].characters );
				}

			},

			saveLocalData() {

				this.localData['0.1'] = {
					characters: this.characters,
				}

				localStorage.setItem('cortexToolkitData', JSON.stringify(this.localData));

			},

			clearLocalData() {
				localStorage.setItem('cortexToolkitData', null);
				window.reload();
			}

		}

	})
	.component('roster',           Roster )
	.component('character',        Character )
	.component('name-editor',      NameEditor )
	.component('portrait-editor',  PortraitEditor )
	.component('trait-editor',     TraitEditor )
	.component('trait-set-editor', TraitSetEditor )
	.component('subtrait-editor',  SubtraitEditor )
	.component('sfx-editor',       SfxEditor )
	.mount('#cortex-toolkit');

});
